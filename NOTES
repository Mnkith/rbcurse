NOTES
=====
/// vim:ts=4:sw=4:tw=80:ai:formatoptions=tcqnl:
/// this was posted with appenddiary.sh

Subject: Update rubyforge
-------------------------

To update the file named index.html on rubyforge use this. password is in  
rubyforge config file.

      scp index.html rkumar@rubyforge.org:/var/www/gforge-projects/rbcurse

* * *

Subject: subwin benefit
-----------------------
Date: 2009-10-09 23:32 

Just found out after playing with subwins that they don't let you write onto  
the window below. Perfect for us for components that overwrite!!  However, no  
way to hide a subwin for later display

* * *

Subject: Upgrading widgets
--------------------------
Date: 2009-11-02 14:45

1. We need to use `create_buffer` either in constructor or repaint  or whenever
   you are likely to have a width and height.  Recommended in beginning of
   repaint().
Use `safe_create_buffer`

2. Use `@buffer_modified = true` in repaint

3. Ensure `print_border` and `printstring` are getting correct coordinates.  Most
   errors happen here.

4. Replace @form.window with @graphic

5. `set_form_col` needs to call `@form.setrowcol` as in rtextarea.
   Also, you need to add cols_panned and rows_panned so the widget knows
   how much it as been panned, and keeps the cursor in correct place.

6. `set_form_row` needs to call @form.setrowcol as in rtextarea. See above entry
   for details.

7. Need to add the following in initialization of container such as rscrollpane
   or rsplitpane:
   `should_create_buffer true`

   Also when creating a widget to put inside a container, use this line (see
   samples below), as this needs to happen at construction time.

8. Remove any `dsl_accessor` on height or width since this will override widget.
   If you create a method, call `super()`.

9. You may have to `print_borders()` in `repaint()`, checking for `@Wrepaint_all` (see
   rtextview.rb). i.e, don't print just once in constructor, since when the
   object is placed inside a splitpane, its size can change.

See testscrollp.rb or testscrollta.rb for working sample.

* * *


Subject: Scrollpane's form
--------------------------
Date: 2009-12-27 20:08

Since scrollpane's child object has no form, scrollpane needs to have its own form 
and hand it to child object. However, set_form was overwriting the existing @graphic
so nothing was printed.
Had to put a check so graphic (buffer) not overwritten. Now the child object does
print correctly with a form object. No crashing regarding nil form.

1. Container objects such as scrollpane and splitpane which have widgets
   with nil forms require to create a form using existing graphic object
   as window and hand that to the child objects.

* * * * * * * *

Subject: Moving cursor in ScrollPane's child
--------------------------------------------
Date: 2009-12-28 23:19

Since child has its own form, had to hack an if clause in child object
(ListScrollable in the case of Textarea) to modify parent forms row and col.
Also added a parent_form in form.

However, this needs to be done in scrollpane or other higher up place, so i
don't have to keep doing it.

ALso what if there are multiple objects in a heirarchy. Splitpane contains
another Splitpane which contains some object. The setting must bubble up all the
way.

* * * * * * * *

Subject: class Form - set_form_rowcol
-------------------------------------
Date: 2009-12-29 15:28

Form should have a method rather than allow direct setting.
This method can percolate up to a parent form if not the same as current.

* * * * * * * *

Subject: More on scrollpane and other widgets
---------------------------------------------
Date: 2009-12-30 18:03

I have added a Form.rows_panned and cols_panned, so that a form know 
how much its objects have been panned by. Otherwise there was no way
of Textarea knowing it had been panned. It would keep resetting the
cursor to the wrong value. rows_panned allows it to account for panning
so the cursor can flash at where insertion is happening.
See Scrollpane, handle_keys, around line 224.

* * * * * * * *

Subject: Scrollpane's cursor out of bounds - known bug
------------------------------------------------------
Date: 2009-12-31 09:42

I've tried various ways to handle this - currently a variable named
outofbounds. However, some little logic error causes the cursor
to lose synch with the caret (insertion point).

So until I can sort that out, we live with the cursor going cruising
across the screen, although it does remain very true to the insertion
point so no data can get mucked up.

* * * * * * * *

Subject: more thoughts on cursor display
----------------------------------------
Date: 2009-12-31 17:14

I deleted the todo item regarding widgets maintain cursor display
themselves, but now i think the insertion point is specfic to some
widgets not all, and that the widget should perhaps maintain it
themselves.

Most widgets highlight a line or item within. There is no editing
happening. On a GUI there really is no cursor. However, textfields and
textareas do have an insertion point (caret?). If they maitain their own
insertion points, then when they are hidden or panned, the cursor would
get hidden automatically since i assume its painted onto the buffer or
pad.

For example, tabbedpanes work just fine in these widgets since they take
care fo their ownfocssing and selection.

* * * * * * * *

Subject: Textarea overwrite problem
-----------------------------------
Date: 2010-01-03 17:54

I think it's like this.. (reference test2.rb sample program)

Textarea uses a pad, which does a `prefresh` onto screen.
All the other widgets (unbuffered) write to a window which does a
`wrefresh`. This refresh overwrites the write that `prefresh` did.

Acco to the manpage, certain optimizations are done with what is
already there on the screen. My guess is that a window wrefresh does not
disturb what is on the right, but it does overwrite what's on the left.

Now, scrollpane and splitpane use a `buffer_to_screen` passing their own
graphic object, so the main window is written onto. I need to confirm
this by placing something on the right. Here, since textarea was not a
child or embedded object, a `pad.refresh` was done.

I think i need to ensure that a `copy_pad_to_win` is done in these cases,
by passing a graphic object. At least the source of this bug is now
clear to me now.

* * * * * * * *

Subject: Thoughts on the buffered (pad) approach
------------------------------------------------
Date: 2010-01-05 12:03

Buffering all widgets means that there will be a huge number of pads
beign created for a screen that has a lot of fields. Lots of copying and
possibilities of errors.

In ordinary cases, there should be only one window, as in the old
version. The buffered approach is only required if a scrollpane or
splitpane is being used, even there only what is embedded will create its
own buffer. That simplifies the whole thing. The usual execution path
will be the old simple one.

It may make more sense for the container to pass a buffer to the child
and so on, rather than each level creating a buffer and copying to the
higher level. That may totally eliminate having to create buffered
objects, just have scrollpane and splitpane create a buffer and hand it
down. I need to think this over, why did i not think of this before.

The reason for this is that each level does not know what will be
displayed and what will be truncated. So it writes things out full, 
or as much is the widget coordinates. The next level does the relevant
truncation. So the current approach is correct, however, when it can be
avoided and one window used, only one should be. This will be in 99%
cases. In anycase, listbox, textarea and textview and table implement
their own scrolling, so one really does not need scrollpane for them.
Scrollpane may be needed when we create a scrollable form. 

So we can have a `should_buffer(boolean)`, which goes the buffer route (if
set true by parent), else things continue with a form.window as before.

added later 2010-01-05 13:24 :
Regarding conditional buffering, what if some component containing components,
such as a listbox or table containing editor components is place in a form which
is placed in a scrollpane. The scrollpane can set `should_buffer` for the child,
but what of all the lower components ? Should this be passed down ?

* * * * * * * *

Subject: Implementing a scrollable form
---------------------------------------
Date: 2010-01-05 12:34

Two approaches come to mind:

1.  Create a form using a pad (i/o of a window). Form will have to
    handle scroll keys if child does not handle them.
    Ensure that pad writes onto physical screen, not a window (like it
    used to).

2.  Create the usual window and scrollpane.
    Make the child a form-widget -- a widget that contains a form, sends
    messages to form. However, the form should be based on a pad.

    In both cases, a form is based on a pad, so objects can be placed in
    a larger area than the physical screen.

* * * * * * * *

Subject: form.setrowcol and rowcol
----------------------------------
Date: 2010-01-05 21:11

i began setting both row and col from `set_form_row`, but it does not know
the current col. `rowcol` seems to return the position where printing
should start, or the cursor should be positioned on entry first time.

So i am now passing nil for c, so col is not disturbed.
test2.rb's listbox is now editing fine, cursor is moving when editing.
However, in scrollpane with pads etc, the cursor is not moving.

* * * * * * * *

Subject: embedded splitpanes
----------------------------
Date: 2010-01-07 19:19

*Case*: splitpane within another splitpane. 

*Examples*: ruby doc or java doc. Now think text mode, no mouse, no
dragging. Open ruby docs or java docs in `links`.

Lets take a realistic scenario of a splitpane which contains a splitpane
as one (or both) components. We've defined some key/s to resize a
splitpane, but now which splitpane gets the key. How does the user
specify which level the key pertains to. 

In textual browsers such as links, "frames" have been used. So you are
inside a frame. Your key pertains to that frame and you tab between
frames. Using splitpanes, when you are in a component you are inside a
splitpane too. So in the case of a splitpane within another, you are in
2 splitpanes. 

When you tab into a splitpane, I'd like to make it easy and put the
focus inside the first component. You can switch between components. But
you are never really focussed on the splitpane. Any keys not processed
by the child components are passed up to the splitpane. Thats how it
does resizing, or changing orientation.

The other option is that you first focus on the splitpane, and then tab
once more to the first component. Ugh ! But it allows you use simple
keys like plus and minus to resize. Thus in a multilevel scrollpane,
you'd need many tabs to get to the actual component.

There's a third option, i do as before, but give a special key to go to
outer splitpane, so conditionally focus can go onto splitpane.

* * * * * * * *

Subject: repaint_all
--------------------
Date: 2010-01-08 20:29

I have added repaint_all and repaint_required in class Widget.
Sometime a parent wants to tell its child to repaint, and there's no
way. The only way was to fire a handler.

Also added a repaint_all, so if some widgets want to print a border or
clear area only on a major change (like dimension change), they can use
this flag. Calling repaint_all, sets repaint_required also. The latter
is for usual data changes.

* * * * * * * *

Subject: Splitpane and cascading dimension changes to child
-----------------------------------------------------------
Date: 2010-01-09 20:37

**Splitpane**, moving divider.

Now by default, changes to width and height are *not* cascaded to child
components.
However, as and when the divider is increased beyond size of first
component, the first component will enlarge and automatically its buffer
is resized.

I've also worked on preventing the crash. Essentially, the screen_buffer
should not become less than the components pane. This can happen in 2
ways, one is the buffer is resized whenever component increases. I was
(by oversight) overriding widget's height having defined a dsl_accessor
in textview.

However, if you don't want to resize the buffer, then one should not
call `set_screen_max_row_col` if it exceeds the warning condition. This
warning is if one is creating a new widget, if it crashes on `copywin`
and Height is more than `smaxrow()` then you'll have a crash. So resize
at that time by simply increasing the widgets height, or else put a
check in widget so that the method is not called for this condition.

* * * * * * * *

Subject: maxlen in rtextview
----------------------------
Date: 2010-01-10 19:28

Made a change in rtextview.
In the constructor, maxlen if nil was set to width-2.
So, if width was changed later maxlen would remain the same. And maxlen
is used as the length (width) of the content to print.

I've never changed the width at runtime, till today, from splitpane, and
this came out. So now unless you explicitly set maxlen, it must remain
nil and be set locally in each method as width-2.

I supposed the same has to be done in rtextarea.

* * * * * * * *

Subject: copy_pad_to_win
------------------------
Date: 2010-01-11 23:47

More and more scenarios are coming up when copy_pad_to_win can either
return a -1 and do nothing, or print less that it should be.

I can't correct more of these in the method, since that would break some
other situation. I have added warnings, though. One will have to check
the log file and see what warnings have been printed. If none, then we
have a new scenario, and the data has to be inspected to figure out.

* * * * * * * *

Subject: regarding create_buffer in repaint
-------------------------------------------
Date: 2010-01-12 12:54

If a widget calls `create_buffer` in repaint, it uses some default values
such as for top and left (0,0). To change these values, from a parent
component such as splitpane, means i change after `repaint()` so the first
paint is off by one row and col. The subsequent paint is okay.

I need to be able to pass values to a widget prior to `repaint()`, so its
`create_buffer` can be influenced.

* * * * * * * *

Subject: cursor positioning form#setrowcol
------------------------------------------
Date: 2010-01-12 22:53

Since i currently go up a heirarchy of forms, passing up the row and col
to be set, i cannot add the col and row offsets of the parent
(enclosing) widgets.
Had i gone up a heirarchy of widgets, I could have added their offsets.

In any case, i think I need to add them as parents, in methods like 
`child()` or `first_component`. Then a method will be needed to pass values
up, and when no parent then set in its form. Each level adds its offset.

OTOH, another option would be when setting a child component, to once and for
all pass down cumulative offsets. Thus, one will not have to keep adding.
However, it is inefficient, is it not to propogate each cursor move up. Won't
that be slow ?
For that matter, won't this copying buffer be slow. Is there no faster way out?


In the case of multiple embedded components, can we not pass down the offsets
and boundaries when setting or moving so that each component writes directly,
and the cursor can be set easily without passing up ? There is a one time
passing down on creation, and moving or resizing. Each component knows its own
absolute position on the form, and there's basically only one form (except maybe
for tabbed panes).

Buffers means that scrollpanes for example only scroll a buffer, the widget does
not have to redraw repeatedly. Repainting is higher level code with many type
conversions, slicing, formatting etc, scrolling is merely a low-level copywin()
call. however, copywin() seems a lot more prone to error (new situations).

Direct painting without a buffer means constant repainting on scrolling, like
happens when we use TextViews and listboxes inbuilt scrolling.
Otoh, it means each component has to implement scrolling. With a scrollpane, we
can have scrollpane do the job, although the child has to write onto a pad.
* * * * * * * *

Subject: update to cursor positioning
-------------------------------------
Date: 2010-01-13 18:26

Just studied the code to see how each textview knows where to print
inside splitpanes. Each component's `@col` is set to where printing has to
start, that's all. I was mistakenly using `@orig_col` which is never
updated. 
Now its fine, which means I don't need `widget#setformrowcol`, the earlier
`form#setrowcol` is fine. Don;t use orig_col in setting cursor,
applies to rtextarea.rb, too.

* * * * * * * *

Subject: speed of splitpane, copying buffers
--------------------------------------------
Date: 2010-01-14 15:44

One can type fast in a textarea as is and see updates immediately. But
when the textarea is inside a splitpane, due to the buffer copying
happening, fast typing updates take time to show up.

Sequence would be as follows:
1. textarea buffer copies onto splitpane buffer
2. Splitpane buffer copies to main form window (earlier it would copy to
   screen directly)
3. form.window does a wrefresh.

Each time you type a character, it goes through the above. We need to
get the innermost widget buffer to write directly to the form.window
somehow.

Also a quick cursor movement, shows the cursor flashing on row below now
and then, although when you move the cursor slowly, it move fine.

* * * * * * * *
